package vulnerability

import (
	"context"
	"errors"
	"fmt"
	"log"
	"twoBinPJ/domains/user"
)

type VulnerabilityService struct {
	Repository IVulnerabilityRepository
	UserServ   user.IUserService
}

func NewVulnerabilityService(repository IVulnerabilityRepository, userServ *user.UserService) *VulnerabilityService {
	return &VulnerabilityService{
		Repository: repository,
		UserServ:   userServ,
	}
}

func (v *VulnerabilityService) ShowVulnerabilityByID(ctx context.Context, id int) (*Vulnerability, error) {
	return v.Repository.GetVulnerabilityByID(id)
}

func (v *VulnerabilityService) CreateVulnerability(ctx context.Context, name, description string) (*Vulnerability, error) {
	users, err := user.ForContext(ctx)
	if err != nil {
		log.Printf("token is incorrect or wrong: %s", err)
		return nil, errors.New("INITIALIZING_TOKEN_ERROR")
	}
	currentUser, err := v.UserServ.GetUserByIDService(users.Id)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	if currentUser.Role != 2 {
		log.Printf("You do not have access to create vulnerability: %v", err)
		return nil, errors.New("CREATE_VULNERABILITY_ERROR")
	}
	return v.Repository.CreateVulnerability(name, description)
}

func (v *VulnerabilityService) UpdateVulnerability(ctx context.Context, name, description *string, vulnerability *Vulnerability) error {
	users, err := user.ForContext(ctx)
	if err != nil {
		log.Printf("token is incorrect or wrong: %s", err)
		return errors.New("INITIALIZING_TOKEN_ERROR")
	}
	currentUser, err := v.UserServ.GetUserByIDService(users.Id)
	if err != nil {
		fmt.Println(err)
		return err
	}

	if currentUser.Role != 2 {
		log.Printf("You do not have access to update vulnerability: %s", err)
		return errors.New("UPDATE_VULNERABILITY_ERROR")
	}
	didUpdate := false

	if name == nil {
		vulnerability.Name = vulnerability.Name
	} else {
		vulnerability.Name = *name
		didUpdate = true
	}

	if description == nil {
		vulnerability.Description = vulnerability.Description
	} else {
		vulnerability.Description = *description
		didUpdate = true
	}

	if !didUpdate {
		return errors.New("no update done")
	}
	err = v.Repository.UpdateVulnerability(name, description, vulnerability.ID)
	if err != nil {
		return err
	}
	return nil
}

func (v *VulnerabilityService) DeleteVulnerability(ctx context.Context, id int) error {
	users, err := user.ForContext(ctx)
	if err != nil {
		log.Printf("token is incorrect or wrong: %s", err)
		return errors.New("INITIALIZING_TOKEN_ERROR")
	}
	currentUser, err := v.UserServ.GetUserByIDService(users.Id)
	if err != nil {
		fmt.Println(err)
		return err
	}

	if currentUser.Role != 2 {
		log.Printf("You do not have access to delete vulnerability: %s", err)
		return errors.New("DELETE_VULNERABILITY_ERROR")
	}
	return v.Repository.DeleteVulnerability(id)
}
